# -*- coding: utf-8 -*-
"""
Created on Mon Sep 11 12:31:33 2023

This library has been developed to communicate with otbiolab23 software.
Different functions will be available to load data from
files generated by software and to write files that will be read 
by software.

@author: PC-Fabio
"""
import os
import sys
import struct
import OTBiolabClasses as otbClasses
import tarfile
import xml.etree.ElementTree as ET
import numpy as np


'''
Global variables
'''
commonFilesPath=os.path.join(os.getenv('APPDATA'),'OT Bioelettronica','OTBiolab4','FileToProcess')

def GetInvolvedFiles():
    files=[];
    file_info=os.path.join(commonFilesPath,"InvolvedFiles.common");
    if(os.path.exists(file_info)):
        with open(file_info, "rb") as file:
            while(True):
                try:
                    path_length=struct.unpack('i', file.read(4))[0]
                    files.append(file.read(path_length).decode('utf-8'));
                except:
                    break;
                    
    return files;


def GetLSBDependingOnDevice(device_title, adapter_title):
    

    LSB=0.00028610
    unit_of_measurement='mV'
    
    if('syncstation' in device_title):
        if('muovi+' in adapter_title or 'muovi' in adapter_title or'sessantaquattro+' in adapter_title or 'sessantaquattro' in adapter_title):
            LSB=0.00028610
            unit_of_measurement='mV'
        elif('due+' in adapter_title or 'quattro+' in adapter_title):
            LSB=0.00024928
            unit_of_measurement='mV'
        elif('quaternions' in adapter_title or 'control' in adapter_title):
            LSB=1
            unit_of_measurement='A.U'
        elif('adapterloadcell' in adapter_title):
            LSB=0.00037217
            unit_of_measurement='mV'
            
        else:
            LSB=0.1526
            unit_of_measurement='mV'
            
    else:
        if('quattrocento' in device_title or 'quattro' in device_title):
            if('control' in adapter_title):
                LSB=1
                unit_of_measurement='A.U'
            elif('direct connection' in adapter_title or 'aux' in adapter_title):
                LSB=0.1526
                unit_of_measurement='mV'
            else:
                LSB=0.00050863;
                unit_of_measurement='mV'
                
            
            
        elif('muovi+' in device_title or 'muovi' in device_title or 'sessantaquattro+' in device_title or 'sessantaquattro' in device_title):
            if('control' in adapter_title):
                LSB=1
                unit_of_measurement='A.U'
            elif('quaternions' in adapter_title):
                LSB=1
                unit_of_measurement='A.U'
            elif('direct connection' in adapter_title or 'aux' in adapter_title):
                LSB=0.1526
                unit_of_measurement='mV'
            else:
                LSB=0.00028610
                unit_of_measurement='mV'
            
        elif('due+' in device_title or 'quattro+' in device_title):
            if('control' in adapter_title):
                LSB=1
                unit_of_measurement='A.U'
            elif('quaternions' in adapter_title):
                LSB=1
                unit_of_measurement='mV'
            else:
                LSB=0.00024928
                unit_of_measurement='mV'
            
        elif('due' in device_title):
            LSB=0.00038147
            unit_of_measurement='mV'
        
        
        elif('emg-usb' in device_title):
            if('control' in adapter_title):
                LSB=1
                unit_of_measurement='A.U'
            elif('direct connection' in adapter_title | 'aux' in adapter_title):
                LSB=0.1526
                unit_of_measurement='mV'
            else:
                pass
            
    return LSB,unit_of_measurement;
            
        

def OpeningOtbPlusFile(path):
    
    tracks=[]
    
    #Get the sig files
    if os.path.exists('tmpopen'):
        # Clean the folder
        file_list = os.listdir('tmpopen')
        for file in file_list:
            file_path = os.path.join('tmpopen', file)
            os.remove(file_path)
    else:
        os.makedirs('tmpopen')

    with tarfile.open(path, 'r') as tar:
        tar.extractall('tmpopen')
    
    #Get the xml file
    abstracts = [file for file in os.listdir('tmpopen') if file.endswith('.xml')]
    
    for abstract in abstracts:
        signals_file_path=abstract[:-4] + '.sig';
        if os.path.exists(os.path.join('tmpopen', signals_file_path)):
            abs_tree = ET.parse(os.path.join('tmpopen', abstract))
            abs_root = abs_tree.getroot()
            
            # Get sampling frequency
            frequency=int(abs_root.attrib['SampleFrequency']);
            device_name=abs_root.attrib['Name'].split(' ')[0].lower().replace(";","");
            total_channels=int(abs_root.attrib['DeviceTotalChannels'])
            n_bits=int(abs_root.attrib['ad_bits'])
            
            #Get the data
            with open(os.path.join('tmpopen', signals_file_path), 'rb') as h:
                
                if(n_bits==16):
                    data = np.fromfile(h, dtype=np.short).astype(float)
                else:
                    data = np.fromfile(h, dtype=int).astype(float)

                data = data.reshape((total_channels,-1), order='F')
                
                for adapter in abs_root.findall('.//Channels/Adapter'):
                    start_index = int(adapter.get('ChannelStartIndex'))
                    number_of_channels=len(adapter.findall('Channel'))
                    LSB, unit_of_measurement=GetLSBDependingOnDevice(device_name,adapter.attrib['ID'].lower());
                    track_data=data[start_index:start_index+number_of_channels,]*LSB;
                    channels=[]
                    title=adapter.find('Channel').attrib['ID'].lower();
                    prefix=adapter.find('Channel').attrib['Prefix'].lower().split(' - ')[0];
                    
                    for channel_data in track_data:
                        channels.append(otbClasses.Channel(channel_data))
                    sections=[]    
                    sections.append(otbClasses.Section(0, len(channels[0].data)/frequency, channels))
                    
                    
                    if('syncstation' in device_name and prefix!="" and prefix!='mustbedeleted'):
                        tracks.append(otbClasses.Track(sections, frequency, number_of_channels,unit_of_measure=unit_of_measurement, title=device_name+ ' - '+title, device=prefix))                    
                    else:
                        tracks.append(otbClasses.Track(sections, frequency, number_of_channels,unit_of_measure=unit_of_measurement, title=device_name+ ' - '+title, device=device_name))                    
 
    return tracks;

def OpeningOTB4File(path):
    '''
    This function open otb4 files to get data.
    The data are organised in tracks.
    
    Args: path(string): otb4 file path
    
    Returns:
        list of tracks
    '''
    
    tracks=[]
    
    #Get the sig files
    if os.path.exists('tmpopen'):
        # Clean the folder
        file_list = os.listdir('tmpopen')
        for file in file_list:
            file_path = os.path.join('tmpopen', file)
            os.remove(file_path)
    else:
        os.makedirs('tmpopen')

    with tarfile.open(path, 'r') as tar:
        tar.extractall('tmpopen')
    
    #Get the xml file
    abstracts = [file for file in os.listdir('tmpopen') if file.endswith('.xml')]
    
    
    #Create the tracks
    for abstract in abstracts:
        if "Track" in abstract:
            
            try:
                abs_tree = ET.parse(os.path.join('tmpopen', abstract))
                abs_root = abs_tree.getroot()
                
                tracks_infos=abs_root.findall('TrackInfo')
                for track_info in tracks_infos:
                    gain=float(track_info.find('Gain').text)
                    adc_nbits=int(track_info.find('ADC_Nbits').text)
                    adc_range=float(track_info.find('ADC_Range').text)
                    unit_of_measurement=track_info.find('UnitOfMeasurement').text
                    unit_of_measurement_factor=float(track_info.find('UnitOfMeasurementFactor').text)
                    channels_in_file=int(track_info.find('TotalChannelsInFile').text)
                    sig_file_path=track_info.find('SignalStreamPath').text
                    acquisition_channel=int(track_info.find('AcquisitionChannel').text)
                    number_of_channels=int(track_info.find('NumberOfChannels').text)
                    sampling_frequency=float(track_info.find('SamplingFrequency').text)
                    sample_size=int(track_info.find('SampleSize').text)
                    
                    subtitle=''
                    if(track_info.find('SubTitle').text!=None):
                        subtitle=track_info.find('SubTitle').text.lower();
                    
                    title=track_info.find('Title').text.lower()+ ' ' + subtitle;
                    device=track_info.find('Device').text.lower();
                    starts=track_info.find('Starts')
                    ends=track_info.find('Ends')
                    
                    sections=[]
                    with open(os.path.join('tmpopen', sig_file_path), 'rb') as h:
                        
                        if(sample_size==2):
                            data = np.fromfile(h, dtype=np.short).astype(float)
                        else:
                            data = np.fromfile(h, dtype=int).astype(float)
    
                        data = data.reshape((channels_in_file,-1), order='F')
                        LSB=(adc_range / (pow(2,adc_nbits))* gain)*unit_of_measurement_factor;
                        
                        for time_index in range(0,len(starts)):
                            start=float(starts[time_index].text);
                            end=float(ends[time_index].text);
                            
                            start_sample=int(start*sampling_frequency);
                            end_sample=int(end*sampling_frequency);
                            
                            
                            track_data=data[acquisition_channel:acquisition_channel+number_of_channels,start_sample:end_sample];
                            channels=[]
                            for channel_data in track_data:
                                channels.append(otbClasses.Channel(channel_data*LSB))
                                
                            sections.append(otbClasses.Section(start, end, channels))
                    
                    tracks.append(otbClasses.Track(sections, sampling_frequency, number_of_channels,unit_of_measure=unit_of_measurement, title=title, device=device))
            except:
                print('ERROR OPENING '+abstract+' FILE')
                    
                
    return tracks;
    
###
#This function is used to load the data from all the files contained in otb4 file
###

def LoadDataFromFile():
    '''
    This function is used to read all the data from a otb4 file
    '''
    
    #Get the file path from args
    args=sys.argv[1:]
    
    if(len(args)>0):    #i can check the first args
        if(".otb4" in args[0]):
            #Opening file and loading data
            filePath=args[0]
            signals=OpeningOTB4File(filePath)
            return signals
            
        else:
            sys.stderr.write("Wrong parameter, it must be a correct otb4 file path")

            
    else:
        sys.stderr.write("No file has been passed to function")
    
    return



def LoadDataFromPythonFolder():
    '''
    This function is used to load data found in a specific folder created by
    OTBiolab software. The files and the folder are created by software when
    a python processing run, or to connect different python processing.
    
    return a dictionary containing the data. This dictionary is organised as 
        follow.
        keys: string containing the file name (track title). Each track is 
            saved in its own file.
        data: a tuple containing the frequency of the track and the samples.
            the samples are organised as a list of channel, each channel is 
            a list of double values. 
    File format: each file created by otb sw is organised as follow:
        each file contains as first 8 byte data the sampling frequency,
        then for each channel there is a first 8 byte value which represents
        the number of samples for channel, and then there are all the samples
        of the correspondent channel.
    '''
    
    if(os.path.exists(commonFilesPath)):
        #Get the files of .data extension
        file_names = [f for f in os.listdir(commonFilesPath) if f.endswith('.data')]
        
        if(len(file_names)>0):
            tracks=[]
            print('Start Data loading...')
            for file_name in file_names:
                sections=[]
                file_path=os.path.join(commonFilesPath,file_name)
                with open(file_path, "rb") as file:
                    title_length=struct.unpack('i', file.read(4))[0]
                    title=file.read(title_length).decode('utf-8')
                    frequency=struct.unpack("d", file.read(8))[0]
                    time_shift = struct.unpack("d", file.read(8))[0]
                    number_of_channels=struct.unpack('i', file.read(4))[0]                    
                    unit_of_measure_length=struct.unpack('i', file.read(4))[0]
                    unit_of_measure=file.read(unit_of_measure_length).decode('utf-8')
                    
                    while True:
                        try:
                            start_time = struct.unpack('d', file.read(8))[0]
                            end_time = struct.unpack('d', file.read(8))[0]
                            
                            channels=[]
                            
                            for channel_index in range(number_of_channels):
                                try:
                                    count = struct.unpack('i', file.read(4))[0]
                                    channel=otbClasses.Channel(struct.unpack(f'{count}d', file.read(count*8)))
                                    channels.append(channel)
                                    
                                except struct.error:
                                    break
                            
                            sections.append(otbClasses.Section(start_time, end_time, channels))
                        except struct.error:
                            break
                
                tracks.append(otbClasses.Track(sections, frequency, number_of_channels, time_shift, unit_of_measure=unit_of_measure,title=title))
            
            print('Concluded Data Loading...')
            return tracks
            
        else:
            sys.stderr.write("No files .data found. Select tracks e run again the processing")
    
    else:
        sys.stderr.write("Cannot find "+commonFilesPath+". Try to select tracks before run")
    
    return
    

def CleanCommonFolder():
    if(os.path.exists(commonFilesPath)):
        #Get old files
        file_paths = [f for f in os.listdir(commonFilesPath) if (f.endswith('.data')|f.endswith('.text'))]
        
        #Clean folder
        for file_path in file_paths:
            os.remove(os.path.join(commonFilesPath,file_path))
    else:
        print('Cannot find '+commonFilesPath+" to save data. Run processing again")

def WriteDataInPythonFolder(tracks):
    '''
    This function is used to save elaborate data to plot them in otbiolab sw
    or for a chain of processings. The input struct needs to respect specific
    features.
    
    Args: tracks is a dictionary containing the data. it needs to be organised 
    as follow:
        key: title of the file which will be the track title and the file name
        data: a tuple containing the sampling frequency of the track and the samples.
            the samples are organised in a list of channel, each channel is a list of double
            containing the data
            
    File Format: the file needs to respect the same structure of "LoadDataFromPythonFolder" function
        check its description to find a detailed explanation.
    
    '''
    
    CleanCommonFolder()
        
    print('Start Data Saving...')
    #Save tracks
    track_index=0
    for track in tracks:
        track.SaveData(commonFilesPath, track_index)
        track_index+=1
                    
    print('Concluded Data Saving')            
  
def WriteChartInPythonFolder(tracks, max_x_value,x_label,y_label):
    CleanCommonFolder()
    print('Start Chart Saving...')
    
    track_index=0
    for track in tracks:
        track.SaveChart(commonFilesPath, track_index,max_x_value, x_label, y_label)
        track_index+=1
    
    print('Concluded Chart Saving...')  

def WriteMessageInPythonFolder(tracks,additional_channel_info):
    CleanCommonFolder()
    print('Start Text Saving...')
    
    #Save tracks
    track_index=0
    for track in tracks:
        track.SaveText(commonFilesPath,track_index,additional_channel_info)
        track_index+=1
    
    
    
